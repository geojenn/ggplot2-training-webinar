---
title: "ggplot2 Webinar Slides"
author: "Shane Cone"
date: "3/23/2020"
output: slidy_presentation
---

# Introduction to R for air quality applications - Data Visualization and ggplot2!

We will be introducing the incredibly powerful and popular ggplot2 package

To wet everyones appetites, let's take a look at just what is possible with the ggplot package in R.
All of these visualizations were made in R, and their code is available online. 

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_Diverging_bars.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_dot_plot.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_dumbbell.png)

# Specialty Charts

Here are some examples of charts that I can't imagine making in Excel...
(I'm not saying they're impossible, I'm saying I'd rather run a super marathon than even try)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_calendar_plot.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_heirarchical_dendrogram.png)

---

![Datanovia](images/datanovia_cluster_dendrogram.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_slope_chart_2.png)

# Time Series

Display and analysis of time series data can be a breeze in R. Here are some visualization examples. 

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_time_series.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_time_series_2.png)

# Frequencies and Histograms

Statistics is the math of data, and R is the programing language of statistics. Here are some awesome frequency charts and histograms that are a breeze to construct in R.

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_bocplot.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_boxplot_with_fill.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_violin_plot.png)

---

![rgraph gallery](images/rgraphgallery_histogram_scatter.png)

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_density_plot.png)

# You can even go spatial!

A lot of spatial analysis is done in R nowadays. It may not have all of the functionality of a GIS software, but spatial data is just a special case of data, and there are many advantages of using a statistical programming for analyzing this type of data.

---

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_open_street.png)

---

![Buzzfeed](images/buzzfeed_spatial.png)

# How is this even possible?

---

![rgraphgallery](images/rgraphgallery_bb8.png)

---

![github/cutterkom](images/github_cutterkom_generative_art2.png)

---

![github/cutterkom](images/github_cutterkom_generative_art1.png)




```{r}
library(tidyverse)
library(lubridate)
dat <- read_csv("C2.1.1CONUSv16.0_2020_p_unit_level_activity_enhanced_v2-tg.csv")
dat_ozone <- read_csv("MLK 2017 AQS data Tidy.csv")

View(dat)
str(dat)
length(dat)

dat_ozone_long <- dat_ozone %>% 
  pivot_longer(-DateTime, names_to = "Measure", values_to = "Values")

dat_ozone_long_daily_summer <- dat_ozone_long %>%
  filter(Measure == "o3", DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  group_by(Date = date(DateTime)) %>%
  summarize("Daily Avg" = mean(Values))

dat_long <- dat %>% 
  select(1:37) %>% 
pivot_longer(7:37, names_to = "Metric", values_to = "Values")

dat_long %>% 
  filter(State == "DE", Metric == "Maximum hourly heat input (mmbtu)") %>% 
  group_by(Facility) %>% 
  summarize("Sum of Heat Output" = sum(Values))

dat_long %>% 
  filter(Metric == "Maximum hourly heat input (mmbtu)") %>% 
ggplot(aes(x = State, y = Values)) +
  geom_col()


```


# Grammar of Graphics

Who here has been frustrated with making charts or graphs in Excel??
Simple charts, with small data, are quick and easy in Excel. But you quickly bump into the limits of what it can do for you. 

In contrast, the possibilities are quite literally endless in R! 

---

We will be discussing how to build visualizations in R using ggplot2. Ggplot2 builds charts using the grammar of graphics approach. 

The grammar of graphics provides a layered approach to building a chart. 

There are three main, necessary arguments to supply to gglpot in order to chart something. 

## Requireid layer 1 - Data

```{r} 
#Starting with the AQS data
ggplot(dat_ozone)
```

The first necessary item is the dataset you want to chart. In this instance, we will be starting with the AQS data that we used in the the open-air webinar.

Here, we passed the dataset("dat_ozone") as the first argument to ggplot.

---

Also, remember, since the data is the first argument, we can also pipe the dataset into ggplot

```{r}
dat_ozone %>% 
  ggplot()
```

This provides the first requirement, but of course, doesn't actually build a chart yet. It's sort of like having data in a table in Excel - it's necessary, but insufficient!


## Required Layer 2 - Aesthetics

Next, you will define some aesthetic mappings to ggplot. 

```{r}
ggplot(dat_ozone, aes(x = DateTime, y = o3))
```


This looks like an empy plot, too, but what have we actually accomplished here?

---

In ggplot2 in R, you build a data visualization piece by piece.The first call just supplies the dataset, but provides no mapping. That is why you get an empty/gray square. However, once we have supplied "aes()", we have mapped our x and y variables. This then also provides the **scale** to ggplot, which is why our x and y axes have both a label, **and** a range! 

(this is a fine detail, but actually important. With one mapping - the call to aes() - we have provided multiple required layers!)

However, we don't have any data actually plotted yet! That is because we have not procided a "geom", or a geometric object to map onto the chart. 

## Required Layer 3 - Geometries!

The part of a chart that everyone is familir with is the geometry, or the "geom", in ggplot2-speak. This defines the "type" of chart, in the sense of bar charts vs. line charts vs. scatterplots, etc. 

We'll start with a scatterplot, whose associated geometry, or geom, is "geom_point"

```{r}
ggplot(dat_ozone, aes(x = DateTime, y = o3)) +
  geom_point()

```

---

Let's talk through this output. First to note - we recieved a warning symbol - the message being, "Removed 107 rows containing missing values (geom_point)". Remember in the "working with data" webinar, that R takes missing data *VERY* seriously. 

The sort of "catch-all" way to remove NA values from your commands is, "na.rm = TRUE". So, if we pass that to the geom call, we will get the same result, but without the warning.

```{r}
ggplot(dat_ozone, aes(x = DateTime, y = o3)) +
  geom_point(na.rm = TRUE)
```

---

So, we have a scatterplot geom that has been mapped onto the exact chart space we had before we called a geomgetry. Remember, our aes() call supplied the scale, and the geom just maps the geometric object onto the datapoints. But, this scatterplot isn't so great. The first issue is that each day has 24 points, and we're mapping an entire year. That's just too much data to make sense of in this way.

Let's take a look at how we might subset this data, and just look at the summer ozone season.

```{r, fig.width= 10, fig.height= 6}
dat_ozone %>% 
  filter(DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  ggplot(aes(x = DateTime, y = o3)) +
  geom_point(na.rm = TRUE)

```


We are using more of the skills we learned in the "working with data" webinar! We piped the dataset to the filter "verb", and selected only the DateTimes after May 1 AND before Oct 1. 



## Adding multiple geoms!

```{r, fig.width= 10, fig.height= 6}
dat_ozone %>% 
  filter(DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  ggplot(aes(x = DateTime, y = o3)) +
  geom_point(na.rm = TRUE) +
  geom_smooth(method = lm)

```

While a linear model line plotted on this dataset isn't actually that informative, it shows that you can build more complex R charts by adding geoms to your plot! In this case, there are two geoms - point and smooth.

## More on Aesthetics

I wanted to talk a little more about this "aesthetic" mapping, and how to do in in ggplot.

In all the above code, we defined the aes() call in the intial ggplot call. Like this:

```{r, include = TRUE}
ggplot(dat_ozone, aes(x = DateTime, y = o3)) +
  geom_point()
```

However, looks what happens when we move the aes() call to the geom, like this:

```{r, include = TRUE}
dat_ozone %>% 
ggplot() +
  geom_point(aes(x = DateTime, y = o3), na.rm = TRUE)
```


It looks exactly the same!
What's happening here?

When you call aes() in the ggplot() call, it will pass that aesthetic mapping to all geoms that you call later, unless you specifcy a different aes() in that geom. 

Some examples:

```{r}
dat_ozone %>% 
  filter(DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  ggplot(aes(x = DateTime, y = o3)) +
  geom_point(na.rm = TRUE) +
  geom_smooth(method = lm)

#same as:
dat_ozone %>% 
  filter(DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  ggplot() +
  geom_point(aes(x = DateTime, y = o3), na.rm = TRUE) +
  geom_smooth(aes(x = DateTime, y = o3), method = lm)


```


We see the two ways of calling aes() here, and both charts are exactly the same! 
So why would you want to call aes() in the geom, instead of in the ggplot call?

well, if you wanted to plot different things to different geoms!



```{r, fig.width= 10, fig.height= 6}
dat_ozone %>% 
  filter(DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  ggplot(aes(x = DateTime, y = o3)) +
  geom_point(na.rm = TRUE) +
  geom_col(data = dat_ozone_long_daily_summer, aes(x = as.POSIXct(Date), y = `Daily Avg`))

```


Forget, for a moment, that this is an ugly chart, and focus, rather on what we accomplished. We were able to map two different gemoetries onto the same chart! 




## Facets

Another layer that can be added to a ggplot visualization is a facet. 

```{r, fig.width=10}
dat_ozone_long %>% 
  filter(Measure == c("o3", "nox", "so2")) %>% 
  ggplot() +
  geom_point(aes(x = DateTime, y = Values, color = Measure)) +
  facet_wrap(~ Measure, scales = "free_y") + #this does the faceting!
  theme_bw() +#this sets the theme to black and white, making a cleaner plot
  guides(colour = guide_legend(override.aes = list(size=5))) #this changes the size of the points in the legend!

```


```{r, fig.height=8}
dat_ozone_long %>% 
  mutate("Month" = month(DateTime, label = T),
         "Day of Month" = mday(DateTime)) %>% #these two lines create a "month" to facet on, and a "day of month" for the x axis
  filter(Measure == "o3") %>% # I just want to plot Ozone
  ggplot() +
  geom_point(aes(x = `Day of Month`, y = Values), color = "Orange") +
  facet_wrap(~ Month) +
  theme_bw() +
  labs(y = "Ozone ppb")

```



# Coordinate system

The concept of a coordinate system may not be something you have thought about before. 
Taken from, "ggplot2: Elegant Graphics for Data Analysis" by Hadley Wickham,

"Coordinate systems have two main jobs:

Combine the two position aesthetics to produce a 2d position on the plot. The position aesthetics are called x and y, but they might be better called position 1 and 2 because their meaning depends on the coordinate system used. For example, with the polar coordinate system they become angle and radius (or radius and angle), and with maps they become latitude and longitude.

In coordination with the faceter, coordinate systems draw axes and panel backgrounds. While the scales control the values that appear on the axes, and how they map from data to position, it is the coordinate system which actually draws them. This is because their appearance depends on the coordinate system: an angle axis looks quite different than an x axis.

---

"There are two types of coordinate system. Linear coordinate systems preserve the shape of geoms:

* coord_cartesian(): the default Cartesian coordinate system, where the 2d position of an element is given by the combination of the x and y positions.

* coord_flip(): Cartesian coordinate system with x and y axes flipped.

* coord_fixed(): Cartesian coordinate system with a fixed aspect ratio.

---

I use the coord_flip a lot, to make charts like this:

![r-statistics top 50 ggplot2 visualizations](images/ggplot_masterlist_Diverging_bars.png)

It's really helpful to flip your bar chart if you have long titles for your factors. 
And the code for this plot:
```{r,include=F}
library(ggplot2)
theme_set(theme_bw())  

# Data Prep
data("mtcars")  # load data
mtcars$`car name` <- rownames(mtcars)  # create new column for car names
mtcars$mpg_z <- round((mtcars$mpg - mean(mtcars$mpg))/sd(mtcars$mpg), 2)  # compute normalized mpg
mtcars$mpg_type <- ifelse(mtcars$mpg_z < 0, "below", "above")  # above / below avg flag
mtcars <- mtcars[order(mtcars$mpg_z), ]  # sort
mtcars$`car name` <- factor(mtcars$`car name`, levels = mtcars$`car name`)  # convert to factor to retain sorted order in plot.

# Diverging Barcharts
ggplot(mtcars, aes(x=`car name`, y=mpg_z, label=mpg_z)) + 
  geom_bar(stat='identity', aes(fill=mpg_type), width=.5)  +
  scale_fill_manual(name="Mileage", 
                    labels = c("Above Average", "Below Average"), 
                    values = c("above"="#00ba38", "below"="#f8766d")) + 
  labs(subtitle="Normalised mileage from 'mtcars'", 
       title= "Diverging Bars") + 
  coord_flip()
```

---

"On the other hand, non-linear coordinate systems can change the shapes: a straight line may no longer be straight. The closest distance between two points may no longer be a straight line.

* coord_map()/coord_quickmap()/coord_sf(): Map projections.

* coord_polar(): Polar coordinates.

* coord_trans(): Apply arbitrary transformations to x and y positions, after the data has been processed by the stat.

---

coord_polar:

```{r}
rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) + 
  geom_tile(data = rect, aes(width = 50, height = 50)) + 
  geom_line(data = line) + 
  xlab(NULL) + ylab(NULL)
base
base + coord_polar("x")
base + coord_polar("y")

```


## Let's talk about labels

Chart labels, that is!
You should always label your charts, to make them easy to udnerstand for your audience. ggplot has numerous ways to add labels, but the easiest is probably with the "lab" call

```{r, fig.width= 10, fig.height= 6}
dat_ozone %>% 
  filter(DateTime >= as.Date('2017-05-01') & DateTime <= as.Date('2017-10-01')) %>% 
  ggplot(aes(x = DateTime, y = o3)) +
  geom_point(na.rm = TRUE) +
  labs(title = "Hourly Ozone Concentrations",
       subtitle = "Time series chart for the summer of 2017",
        x = "Date",
        y = "Ozone (ppb)")


```




